name: DefectDojo Scan (Fixed with Python)

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

env:
  # Token de DefectDojo (Demo)
  DOJO_TOKEN: "548afd6fab3bea9794a41b31da0e9404f733e222"
  
  # URL de tu archivo en GitHub
  OPENAPI_URL: "https://raw.githubusercontent.com/Jneira00001/APIv2_DAST/main/openapi.json"
  
  # El servidor real donde haremos el ataque
  API_TARGET: "https://demo.defectdojo.org"

jobs:
  zap_scan:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Preparar Directorios
        run: |
          mkdir -p ./zap/wrk
          chmod 777 ./zap/wrk
          echo "TIMESTAMP=$(date +'%Y%m%d-%H%M%S')" >> $GITHUB_ENV

      # 1. PYTHON AL RESCATE üêç
      # Este paso descarga el JSON y le ESCRIBE la URL del servidor dentro.
      # As√≠ ZAP no tiene excusa para decir "0 URLs".
      - name: üì• Descargar y Corregir JSON
        shell: python
        env:
          URL_JSON: ${{ env.OPENAPI_URL }}
          URL_SERVER: ${{ env.API_TARGET }}
        run: |
          import os
          import json
          import urllib.request
          import sys

          print("--- INICIANDO CORRECCI√ìN DEL JSON ---")
          
          # 1. Descargar
          url = os.environ['URL_JSON']
          print(f"‚¨áÔ∏è Descargando de: {url}")
          try:
              with urllib.request.urlopen(url) as response:
                  content = response.read()
                  data = json.loads(content)
          except Exception as e:
              print(f"‚ùå Error descargando/leyendo JSON: {e}")
              sys.exit(1)

          # 2. Diagn√≥stico
          paths = data.get("paths", {})
          print(f"‚úÖ Rutas encontradas en el archivo original: {len(paths)}")
          
          # 3. INYECCI√ìN QUIR√öRGICA DEL SERVIDOR
          target = os.environ['URL_SERVER']
          print(f"üîß Inyectando bloque 'servers' con: {target}")
          
          # Sobrescribimos o creamos la lista de servidores
          data["servers"] = [{"url": target}]

          # 4. Guardar archivo final corregido
          output_path = "./zap/wrk/ready.json"
          with open(output_path, 'w') as f:
              json.dump(data, f, indent=2)
          
          print(f"‚úÖ Archivo guardado en {output_path}. ¬°Listo para escanear!")

      # 2. Configurar Autenticaci√≥n
      - name: Configurar Auth ZAP
        run: |
          cat <<EOF > ./zap/wrk/zap_options.prop
          replacer.full_list(0).description=auth
          replacer.full_list(0).enabled=true
          replacer.full_list(0).matchtype=REQ_HEADER
          replacer.full_list(0).matchstr=Authorization
          replacer.full_list(0).replacement=Token $DOJO_TOKEN
          EOF
          chmod 777 ./zap/wrk/zap_options.prop

      # 3. EJECUTAR ZAP (Weekly)
      - name: Ejecutar Escaneo ZAP
        run: |
          echo "üöÄ Iniciando escaneo..."
          
          # Usamos zap-weekly porque tiene mejor soporte para OpenAPI 3.0.3
          # Usamos -S (Safe Mode) para escanear r√°pido las 500 URLs
          
          docker run --rm -u 0 \
            -v $(pwd)/zap/wrk:/zap/wrk:rw \
            zaproxy/zap-weekly zap-api-scan.py \
            -t /zap/wrk/ready.json \
            -f openapi \
            -z "-configfile /zap/wrk/zap_options.prop" \
            -S \
            -r /zap/wrk/reporte.html \
            -J /zap/wrk/reporte.json \
            -l WARN \
            || echo "‚ö†Ô∏è ZAP finaliz√≥."

      - name: Verificar y Subir
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: Reporte-DefectDojo
          path: ./zap/wrk/
